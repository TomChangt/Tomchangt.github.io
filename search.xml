<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM类加载器学习笔记]]></title>
    <url>%2F2020%2F04%2F08%2FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录一下学习jvm类加载这一章节的知识点，方便日后查阅. 类的加载、连接与初始化 加载：查找并加载类的二进制数据 连接: 验证：确保被加载的类的正确性 准备：为类的静态变量分配内存，并将其初始化为默认值 解析：把类中的符号引用转换为直接引用 初始化：为类的静态变量赋予正确的初始值 Java程序对类的使用方式可分为两种 主动使用（七种） 创建类的实例 访问每个类或者接口的静态变量，或者对该静态遍历赋值 调用类的静态方法 反射（如Class.forName(“com.xx.Test”)） 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类（main方法） JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化,则初始化 被动使用 所有的Java虚拟机实现必须在每个类或者接口被Java程序首次主动使用时才初始化他们 类的加载 类的加载:指的是将类的。class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个Java.lang.Class对象（规范并没有说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区的数据结构 类的加载方式 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将java源文件动态编译为.class文件（将JAVA源文件动态编译这种情况会在动态代理和web开发中jsp转换成Servlet） 时序图 ![](01.png) 类加载过程 ![](02.png) 类加载器 Java虚拟机自带的加载器 根加载器(Bootstrap)：该加载器没有父加载器，它负责加载虚拟机中的核心类库。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有集成java.lang.ClassLoader类。 扩展类加载器(Extension)：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre\lib\ext子目录（扩展目录）下加载类库，如果把用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯java类，是java.lang.ClassLoader的子类。 系统（应用）加载器(System)：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器时纯java类，是java.lang.ClassLoader的子类。 用户自定义的类加载器 java.lang.ClassLoader的子类 用户可以定制类的加载方式 根类加载器–&gt;扩展类加载器–&gt;系统应用类加载器–&gt;自定义类加载器,类加载器并不需要等到某个类被“首次主动使用”时再加载它。 JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类才报告错误（LinkageError错误），如果这个类没有被程序主动使用，那么类加载器就不会报告错误。 类加载器用来把类加载到java虚拟机中。从JDK1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。 类被加载后，就进入连接阶段。连接阶段就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。 类的连接-验证 1）类文件的结构检查 2）语义检查 3）字节码验证 4）二进制兼容性的验证 类的连接-准备 在准备阶段，java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0； 初始化 在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：（1）在静态变量的声明处进行初始化；（2）在静态代码块中进行初始化。 类的初始化步骤： （1）假如这个类还没有被加载和连接，那就先进行加载和连接 （2）假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类 （3）假如类中存在初始化语句，那就依次执行这些初始化语句 当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则不适用于接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定的接口的静态变量时，才会导致该接口的初始化。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring5.1.x源码学习——源码环境搭建]]></title>
    <url>%2F2019%2F04%2F23%2Fspring5-1-x%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[作者也工作这么多年了,工作用到最多的框架就是spring了,但是从来也没有去读过spring源码,所以决定以写blog的方式记录一下我的spring源码学习之旅,本篇文章将记录spring的源码环境搭建. 环境准备 作者用的的macbook pro. spring5要求jdk最低版本是8,所以作者用的是jdk1.8.0_111. spring源码是基于gradle构建的,所以需要安装gradle.mac下安装gradle因为还是很方便的(自行google),只不过下载可能需要科学工具,这里作者用到的是gradle 4.10.3. 作者用到的ide工具是idea2019(官网直接下载旗舰版,找马云爸爸要注册码). 这里有点要注意下,低版本的idea对gradle的支持不是很好,作者之前用idea2016导spring的时候出现过好多坑,所以建议升级到较新的idea. spring源码下载 基本spring源码下载分二种,一种是git直接下载,一种是去官方下载zip包,这里作者是直接去官网下载spring5.1.x的zip包. spring源码导入 在编译之前安装进入解压目录找到import-into-idea.md文件,这个文件告诉了你导入idea要注意的一些事项,例如先要编译spring-core 和 spring-oxm 模块等等,接下来我就用截图展示下我编译的步骤. 至此spring源码已经导入到idea里面了,接下来我便会开始开启我的spring源码阅读之旅.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO 学习笔记]]></title>
    <url>%2F2019%2F04%2F21%2FJava%20NIO%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Java NIO是java 1.4之后新出的一套IO接口，这里的的新是相对于原有标准的Java IO和Java Networking接口。NIO提供了一种完全不同的操作方式。 概览 这里就不过多的去解释一些概念性的东西了,直奔主题.NIO包含下面几个核心的组件： Buffer Channel Selector 整个NIO体系包含的类远远不止这几个，但是在我看来Channel,Buffer和Selector组成了这个核心的API. 通道和缓冲区（Channel and Buffer）通常来说NIO中的所有IO都是从Channel开始的。Channel和流有点类似。通过Channel，我们即可以从Channel把数据写到Buffer中，也可以把数据冲Buffer写入到Channel,如下所示: 基本的Channel实现有以下这些： FileChannel DatagramChannel SocketChannel ServerSocketChannel 核心的buffer实现有这些： ByteBuffer CharBuffer DoubleBuffer FloatBuffer IntBuffer LongBuffer ShortBuffer 这些Buffer涵盖了可以通过IO操作的基础类型：byte,short,int,long,float,double以及characters. NIO实际上还包含一种MappedBytesBuffer,一般用于和内存映射的文件. 选择器（Selector）Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。 缓冲区(Buffer) buffer就是一块内存，你可以写入数据，并且在之后读取它。这块内存被包装成NIO buffer对象，它提供了一些方法来让你更简单地操作内存。 Buffer的基本使用利用Buffer读写数据，通常遵循四个步骤: 把数据写入buffer 调用flip,切换读写模式 从Buffer中读取数据 调用buffer.clear()或者buffer.compact() 在写buffer的时候，buffer会跟踪写入了多少数据，需要读buffer的时候，需要调用flip()来将buffer从写模式切换成读模式，读模式中只能读取写入的数据，而非整个buffer,当数据都读完了，你需要清空buffer以供下次使用，可以有2种方法来操作: 调用clear() 调用compact() 区别：clear方法清空整个buffer，compact方法只清除你已经读取的数据，未读取的数据会被移到buffer的开头，此时写入数据会从当前数据的末尾开始.这里有一个简单的buffer案例: public static void main(String[] args) { IntBuffer intBuffer = IntBuffer.allocate(10); for(int i = 0;i&lt;intBuffer.capacity();++i){ //往buffer放数据 intBuffer.put(i*2); } //切换成读模式 intBuffer.flip(); while (intBuffer.hasRemaining()) { System.out.println(&quot;buffer data : &quot;+intBuffer.get()); } }Buffer的容量，位置，上限（Buffer Capacity, Position and Limit）buffer最主要的三个属性是需要我们理解的: 容量(Capacity):缓冲区能够容纳的数据元素的最大数量.容量在缓冲区创建时被设定,并且永远不能被改变。 上界(Limit):写模式中等价于buffer的大小,即capacity;读模式中为当前缓冲区中一共有多少数据,即可读的最大位置.这意味着当调用filp()方法切换成读模式时,limit的值变成position的值,而position重新指向0. 位置(Position):下一个要被读或写的元素的位置.初始化为0,buffer满时,position最大值为capacity-1.切换成读模式的时候,position指向0.Position会自动由相应的get()和put()函数更新。 position和limit的值在读/写模式中是不一样的,capacity的值永远表示buffer的大小。 下图解释了在读/写模式中Capacity,Position和Limit的含义: 关于 Direct Buffer 和 Non-Direct Buffer 的区别Direct Buffer: 所分配的内存不在JVM堆上,不受GC的管理.(但是Direct Buffer的Java对象是由GC管理的,因此当发生GC,对象被回收时,Direct Buffer也会被释放) 因为Direct Buffer不在JVM堆上分配,因此Direct Buffer对应用程序的内存占用的影响就不那么明显(实际上还是占用了这么多内存,但是JVM不好统计到非JVM管理的内存.) 申请和释放Direct Buffer的开销比较大.因此正确的使用Direct Buffer的方式是在初始化时申请一个Buffer,然后不断复用此buffer,在程序结束后才释放此 buffer. 使用Direct Buffer时,当进行一些底层的系统IO操作时,效率会比较高,因为此时JVM不需要拷贝buffer中的内存到中间临时缓冲区中. Non-Direct Buffer: 直接在JVM堆上进行内存的分配,本质上是byte[]数组的封装. 因为Non-Direct Buffer在JVM堆中,因此当进行操作系统底层IO操作中时,会将此buffer的内存复制到中间临时缓冲区中.因此Non-Direct Buffer的效率就较低. 通道(Channel) 通常来说, 所有的NIO的 I/O 操作都是从Channel开始的. 一个Channel类似于一个Stream.主要有以下几点区别： Channel可以读也可以写，Stream一般来说是单向的（只能读或者写）。 Channel可以异步读写。 Channel总是基于缓冲区Buffer来读写。 Channel 的主要类型有: FileChannel用于文件的数据读写. DatagramChannel用于UDP的数据读写。 SocketChannel用于TCP的数据读写。 ServerSocketChannel允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel.在服务器端使用. 这有一个利用FileChannel进行文件拷贝的例子： public static void main(String[] args) throws Exception { String fileInStr = &quot;fileCopy_in.txt&quot;; String fileOutStr = &quot;fileCopy_out.txt&quot;; RandomAccessFile inputFile = new RandomAccessFile(fileInStr,&quot;r&quot;); RandomAccessFile outFile = new RandomAccessFile(fileOutStr,&quot;rw&quot;); long length = new File(fileInStr).length(); FileChannel inputFileChannel = inputFile.getChannel(); FileChannel outFileChannel = outFile.getChannel(); MappedByteBuffer inputData = inputFileChannel.map(FileChannel.MapMode.READ_ONLY, 0, length); Charset charset = Charset.forName(&quot;utf-8&quot;); CharsetDecoder charsetDecoder = charset.newDecoder(); CharsetEncoder charsetEncoder = charset.newEncoder(); CharBuffer charBuffer = charsetDecoder.decode(inputData); ByteBuffer outByteBuffer = charsetEncoder.encode(charBuffer); outFileChannel.write(outByteBuffer); inputFile.close(); outFile.close(); }选择器(Selector) Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写.如此可以实现单线程管理多个channels,也就是可以管理多个网络链接. 为什么使用Selector用单线程处理多个channels的好处是我需要更少的线程来处理channel.实际上,你甚至可以用一个线程来处理所有的channels.从操作系统的角度来看,切换线程开销是比较昂贵的,并且每个线程都需要占用系统资源,因此暂用线程越少越好。需要留意的是,现代操作系统和CPU在多任务处理上已经变得越来越好,所以多线程带来的影响也越来越小.如果一个CPU是多核的,如果不执行多任务反而是浪费了机器的性能.不过这些设计讨论是另外的话题了。简而言之,通过Selector我们可以实现单线程操作多个channel. 创建SelectorSelector selector = Selector.open();向Selector注册通道channel.configureBlocking(false); SelectionKey key = channel.register(selector,Selectionkey.OP_READ);注意,如果一个Channel要注册到Selector中,那么这个Channel必须是非阻塞的,即channel.configureBlocking(false);因为Channel必须要是非阻塞的,因此FileChannel是不能够使用选择器的, 因为FileChannel都是阻塞的,注意register的第二个参数，这个参数是一个“关注集合”，代表我们关注的channel状态，有四种基础类型可供监听： Connect Accept Read Write 一个channel触发了一个事件也可视作该事件处于就绪状态.因此当channel与server连接成功后，那么就是“连接就绪”状态.server channel接收请求连接时处于“可连接就绪”状态。channel有数据可读时处于“读就绪”状态。channel可以进行数据写入时处于“写就绪”状态,上述的四种就绪状态用SelectionKey中的常量表示如下: SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 如果对多个事件感兴趣可利用位的或运算结合多个常量,比如: int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 我们利用register方法把Channel注册到了Selectors上,这个方法的返回值是SelectionKeys,这个返回的对象包含了一些比较有价值的属性: The interest set The ready set The Channel The Selector An attached object (optional) Interest Set这个“关注集合”实际上就是我们希望处理的事件的集合，它的值就是注册时传入的参数，我们可以用按为与运算把每个事件取出来: int interestSet = selectionKey.interestOps(); boolean isInterestedInAccept = interestSet &amp; SelectionKey.OP_ACCEPT; boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT; boolean isInterestedInRead = interestSet &amp; SelectionKey.OP_READ; boolean isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE; Ready Set“就绪集合”中的值是当前channel处于就绪的值，一般来说在调用了select方法后都会需要用到就绪状态，select的介绍在胡须文章中继续展开。 int readySet = selectionKey.readyOps();从“就绪集合”中取值的操作类似月“关注集合”的操作,当然还有更简单的方法，SelectionKey提供了一系列返回值为boolean的的方法: selectionKey.isAcceptable(); selectionKey.isConnectable(); selectionKey.isReadable(); selectionKey.isWritable();Channel + Selector从SelectionKey操作Channel和Selector非常简单: Channel channel = selectionKey.channel(); Selector selector = selectionKey.selector(); Attaching Objects我们可以给一个SelectionKey附加一个Object，这样做一方面可以方便我们识别某个特定的channel，同时也增加了channel相关的附加信息。例如，可以把用于channel的buffer附加到SelectionKey上: selectionKey.attach(theObject); Object attachedObj = selectionKey.attachment();附加对象的操作也可以在register的时候就执行: SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);从Selector中选择channel一旦我们向Selector注册了一个或多个channel后，就可以调用select来获取channel.select方法会返回所有处于就绪状态的channel.select方法具体如下: int select() int select(long timeout) int selectNow() select()方法在返回channel之前处于阻塞状态.select(long timeout)和select做的事一样，不过他的阻塞有一个超时限制.selectNow()不会阻塞,根据当前状态立刻返回合适的channel.select()方法的返回值是一个int整形,代表有多少channel处于就绪了.也就是自上一次select后有多少channel进入就绪.举例来说,假设第一次调用select时正好有一个channel就绪,那么返回值是1,并且对这个channel做任何处理，接着再次调用select,此时恰好又有一个新的channel就绪,那么返回值还是1,现在我们一共有两个channel处于就绪,但是在每次调用select时只有一个channel是就绪的. selectedKeys()在调用select并返回了有channel就绪之后，可以通过选中的key集合来获取channel，这个操作通过调用selectedKeys()方法: Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); 还记得在register时的操作吧，我们register后的返回值就是SelectionKey实例，也就是我们现在通过selectedKeys()方法所返回的SelectionKey.遍历这些SelectionKey可以通过如下方法: Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if(key.isAcceptable()) { // a connection was accepted by a ServerSocketChannel. } else if (key.isConnectable()) { // a connection was established with a remote server. } else if (key.isReadable()) { // a channel is ready for reading } else if (key.isWritable()) { // a channel is ready for writing } keyIterator.remove(); }上述循环会迭代key集合,针对每个key我们单独判断他是处于何种就绪状态.注意keyIterater.remove()方法的调用,Selector本身并不会移除SelectionKey对象,这个操作需要我们收到执行.当下次channel处于就绪是,Selector任然会吧这些key再次加入进来.SelectionKey.channel返回的channel实例需要强转为我们实际使用的具体的channel类型,例如ServerSocketChannel或SocketChannel. wakeUp()由于调用select而被阻塞的线程,可以通过调用Selector.wakeup()来唤醒即便此时已然没有channel处于就绪状态.具体操作是，在另外一个线程调用wakeup,被阻塞与select方法的线程就会立刻返回。 close()当操作Selector完毕后,需要调用close方法.close的调用会关闭Selector并使相关的SelectionKey都无效.channel本身不管被关闭. 完整的Selector案例Server端: public class NioServer { private static Map&lt;String,SocketChannel&gt; channelMap = new HashMap(); private static Map&lt;Integer, BiConsumer&lt;SelectionKey,Selector&gt;&gt; rule = new HashMap(); public static void acceptable(SelectionKey selectionKey,Selector selector){ try { ServerSocketChannel server = (ServerSocketChannel)selectionKey.channel(); SocketChannel client = server.accept(); client.configureBlocking(false); client.register(selector,SelectionKey.OP_READ); String key = &quot;【&quot;+ UUID.randomUUID().toString() +&quot;】&quot;; channelMap.put(key,client); }catch (Exception e){ e.printStackTrace(); } } public static void readable(SelectionKey selectionKey,Selector selector){ try { SocketChannel client = (SocketChannel)selectionKey.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int count = client.read(byteBuffer); if(count&gt;0) { byteBuffer.flip(); Charset charset = Charset.forName(&quot;utf-8&quot;); String receivedMessage = String.valueOf(charset.decode(byteBuffer).array()); String clientKey = channelMap.entrySet().stream().filter(entry -&gt; entry.getValue() == client).findFirst(). map(entry -&gt; entry.getKey()).orElse(null); final String clientReceivedMessage = clientKey + &quot; : &quot; + receivedMessage; System.out.println(clientReceivedMessage); //把消息广播出去 channelMap.entrySet().stream().filter(entry-&gt;!entry.getKey().equals(clientKey)) .forEach(entry-&gt;{ try { SocketChannel otherClient = entry.getValue(); ByteBuffer writeBuffer = ByteBuffer.allocate(1024); writeBuffer.put(clientReceivedMessage.getBytes()); writeBuffer.flip(); otherClient.write(writeBuffer); }catch (Exception e){ e.printStackTrace(); } }); } }catch (Exception e){ e.printStackTrace(); } } public static void main(String[] args) { rule.put(SelectionKey.OP_ACCEPT,NioServer::acceptable); rule.put(SelectionKey.OP_READ,NioServer::readable); try { ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.configureBlocking(false); ServerSocket socket = serverSocketChannel.socket(); socket.bind(new InetSocketAddress(&quot;127.0.0.1&quot;,8899)); Selector selector = Selector.open(); serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (true){ try { selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); selectionKeys.forEach(selectionKey -&gt; { if (selectionKey.isAcceptable()) { rule.get(SelectionKey.OP_ACCEPT).accept(selectionKey, selector); } else if (selectionKey.isReadable()) { rule.get(SelectionKey.OP_READ).accept(selectionKey, selector); } }); selectionKeys.clear(); }catch (Exception e){ e.printStackTrace(); } } }catch (Exception e){ e.printStackTrace(); } } } Client端: public class NioClient { public static void main(String[] args) { try { SocketChannel socketChannel = SocketChannel.open(); socketChannel.configureBlocking(false); Selector selector = Selector.open(); socketChannel.register(selector, SelectionKey.OP_CONNECT); socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,8899)); while (true){ selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); selectionKeys.forEach(selectionKey-&gt;{ try { if (selectionKey.isConnectable()) { SocketChannel client = (SocketChannel)selectionKey.channel(); if(client.isConnectionPending()){ client.finishConnect(); ByteBuffer writeBuffer = ByteBuffer.allocate(1024); writeBuffer.put((LocalDateTime.now() + &quot; 连接成功....&quot;).getBytes()); writeBuffer.flip(); client.write(writeBuffer); ExecutorService executorService = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory()); executorService.submit(()-&gt;{ while (true){ try { writeBuffer.clear(); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String sendMessage = br.readLine(); writeBuffer.put(sendMessage.getBytes()); writeBuffer.flip(); client.write(writeBuffer); }catch (Exception e){ e.printStackTrace(); } } }); } client.register(selector,SelectionKey.OP_READ); }else if(selectionKey.isReadable()){ SocketChannel client = (SocketChannel)selectionKey.channel(); ByteBuffer readBuffer = ByteBuffer.allocate(1024); int count = client.read(readBuffer); if(count&gt;0){ String receivedMessage = new String(readBuffer.array(),0,count); System.out.println(receivedMessage); } } }catch (Exception e){ e.printStackTrace(); } }); selectionKeys.clear(); } }catch (Exception e){ e.printStackTrace(); } } }]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>NIO</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 博客搭建教程]]></title>
    <url>%2F2019%2F04%2F20%2FHexo-Github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近有想法重新开始写博客了,随着年纪越来越大,需要有些沉淀的东西.16年的时候用hexo+github搭建过博客系统,于是花了点时间重新弄了一遍.我就稍稍分享一下搭建过程,当作是我这个博客的第一篇文章. 系统环境 macOS Mojave 10.14.5 Nodejs v12.1.0 Npm v6.9.0 Git v2.20.1 安装 Hexo因为本人本身是后端开发,加上系统用的是macOS,所有git和node都有提前装好,网上很多mac下安装git和node的教程,我这里就不阐述了.安装好git和node以后开始安装Hexo.找一个合适的目录来存放你的博客文件,比如我这里新建了一个blog文件夹来放置我的博客文件 ~/WorkStation/WorkStation/blog,进入blog文件夹下开始安装. 1.安装hexonpm install -g hexo-cli2.初始化hexohexo init3.安装必要组件npm install安装完成后我本地目录结构如下: 这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以访问了,效果如下: 4.使用 HexoHexo经常会用到的命令: hexo clean hexo generate hexo server hexo deploy Hexo命令大多可以缩写,比如hexo s 、 hexo d等等.更多详细命令可以参照官方文档. 部署到Github 1.创建Repository在自己的github上新建一个repository,这里注意一下我名字tomchangt,所以我的repository name要填写tomchangt.github.io,名字遵从 yourname.github.io格式,不过这里填错了也没关系,后面可以修改回来. 2.链接github与本地打开terminal,然后输入下面命令: git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot;生成密钥SSH key: ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;然后找到刚才生成的.ssh文件下的文件id_rsa.pub密钥,用文本编辑器打开复制里面的内容. 打开你的github,在点击settings,在点击SSH and GPG keys,新建一个ssh,名字可以随便.然后将刚才复制id_rsa.pub里的内容复制到key里面,点击add ssh key即可. 3.配置本地hexo在Hexo目录下的_config.yml文件下修改以下信息 # Deployment # Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: https://github.com/xxxx/xxxx.github.io.git branch: master安装hexo deployer插件 npm install hexo-deployer-git --save执行下面命令,将hexo生成静态文件提交到github上,过一会你就可以在https://xxxxxx.github.io下看到博客内容了. 其他 简单的就写这么多吧,其实网上Hexo+Github建博客教程太多了,我也只是记录以下我建立博客的一个过程,并且将它当作我博客的第一篇文章,算是一个新的开始吧.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
