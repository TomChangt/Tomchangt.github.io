<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tom&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tomchangt.github.io/"/>
  <updated>2020-04-09T01:58:47.638Z</updated>
  <id>https://tomchangt.github.io/</id>
  
  <author>
    <name>tom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM类加载器学习笔记</title>
    <link href="https://tomchangt.github.io/2020/04/08/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://tomchangt.github.io/2020/04/08/JVM类加载器学习笔记/</id>
    <published>2020-04-08T07:44:45.000Z</published>
    <updated>2020-04-09T01:58:47.638Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下学习jvm类加载这一章节的知识点，方便日后查阅.</p><a id="more"></a><h3 id="类的加载、连接与初始化"><a href="#类的加载、连接与初始化" class="headerlink" title="类的加载、连接与初始化"></a>类的加载、连接与初始化</h3><hr><ul><li><p>加载：查找并加载类的二进制数据</p></li><li><p>连接:</p><ul><li>验证：确保被加载的类的正确性</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值</li><li>解析：把类中的符号引用转换为直接引用</li></ul></li><li><p>初始化：<strong>为类的静态变量赋予正确的初始值</strong></p></li></ul><h3 id="Java程序对类的使用方式可分为两种"><a href="#Java程序对类的使用方式可分为两种" class="headerlink" title="Java程序对类的使用方式可分为两种"></a>Java程序对类的使用方式可分为两种</h3><hr><ul><li><p>主动使用（<strong>七种</strong>）</p><ul><li>创建类的实例</li><li>访问每个类或者接口的静态变量，或者对该静态遍历赋值</li><li>调用类的静态方法</li><li>反射（如Class.forName(“com.xx.Test”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类（main方法）</li><li>JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化,则初始化</li></ul></li><li><p>被动使用</p></li><li><p>所有的Java虚拟机实现必须在每个类或者接口被Java程序<strong>首次主动使用</strong>时才初始化他们</p></li></ul><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><hr><ul><li><p>类的加载:指的是将类的。class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个Java.lang.Class对象（规范并没有说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区的数据结构</p></li><li><p>类的加载方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将java源文件动态编译为.class文件（将JAVA源文件动态编译这种情况会在动态代理和web开发中jsp转换成Servlet）</li></ul></li><li><p>时序图</p><p>  <img src="01.png" alt>  </p></li><li><p>类加载过程</p><p>  <img src="02.png" alt>  </p></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><hr><ul><li><p>Java虚拟机自带的加载器</p><ul><li>根加载器(Bootstrap)：该加载器没有父加载器，它负责加载虚拟机中的核心类库。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有集成java.lang.ClassLoader类。</li><li>扩展类加载器(Extension)：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre\lib\ext子目录（扩展目录）下加载类库，如果把用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯java类，是java.lang.ClassLoader的子类。</li><li>系统（应用）加载器(System)：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器时纯java类，是java.lang.ClassLoader的子类。</li></ul></li><li><p>用户自定义的类加载器</p><ul><li>java.lang.ClassLoader的子类</li><li>用户可以定制类的加载方式</li></ul></li><li><p>根类加载器–&gt;扩展类加载器–&gt;系统应用类加载器–&gt;自定义类加载器,类加载器并不需要等到某个类被“首次主动使用”时再加载它。</p></li><li><p>JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类才报告错误（LinkageError错误），如果这个类没有被程序主动使用，那么类加载器就不会报告错误。</p></li><li><p>类加载器用来把类加载到java虚拟机中。从JDK1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。</p></li><li><p>类被加载后，就进入连接阶段。连接阶段就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。</p><ul><li><p>类的连接-验证 1）类文件的结构检查 2）语义检查 3）字节码验证 4）二进制兼容性的验证</p></li><li><p>类的连接-准备 在准备阶段，java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">long</span> b;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化,在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：（1）在静态变量的声明处进行初始化；（2）在静态代码块中进行初始化。</p></li><li><p>类的初始化步骤：（1）假如这个类还没有被加载和连接，那就先进行加载和连接 （2）假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类 （3）假如类中存在初始化语句，那就依次执行这些初始化语句 当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则不适用于接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定的接口的静态变量时，才会导致该接口的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当一个接口在初始化时，并不要求其父接口都完成初始化</span></span><br><span class="line"><span class="comment">* 只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoad5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild5.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyParent5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">9</span>; <span class="comment">//前面省了public static final</span></span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread 初始化了"</span>);<span class="comment">//如果父接口初始化了这句应该输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChild5</span> <span class="keyword">implements</span> <span class="title">MyParent5</span> </span>&#123;     <span class="comment">//接口属性默认是 public static final</span></span><br><span class="line">    String b = LocalDateTime.now().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取类加载起的方法</p><p>   <img src="04.png" alt> </p><p> 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p></li></ul></li></ul><h3 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h3><hr><p>在父亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根加载器之外，其余的类加载器都有一个父加载器</p><ul><li><p>若有一个类能够成功加载Test类，那么这个类加载器被称为<strong>定义类加载器</strong>，所有能成功返回Class对象引用的类加载器（包括定义类加载器）称为<strong>初始类加载器</strong>。</p><p>  <img src="05.png" alt="类加载器的(双亲委派机制)父亲委托机制"></p></li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String filePost = <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//将系统类加载器当作该类的父类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);<span class="comment">//显示指定该类的父类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        System.out.println(classLoaderName+<span class="string">"的findClass,输出这句话说明我们自己的类加载器加载了指定的类"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        name = name.replace(<span class="string">"."</span>, File.separator);<span class="comment">//File.separator根据操作系统而变化</span></span><br><span class="line">        <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(path+name + filePost));</span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream =  <span class="keyword">new</span> ByteArrayOutputStream()</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (len = is.read())) &#123;</span><br><span class="line">                byteArrayOutputStream.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] data  = byteArrayOutputStream.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(<span class="string">"myCustomClassLoader"</span>);</span><br><span class="line">        classLoader.setPath(<span class="string">"/Users/ct/Downloads/testclassload/"</span>);</span><br><span class="line">        test(classLoader);</span><br><span class="line">        classLoader = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>); <span class="comment">// jvisualvm 查看当前java进程 -XX:+TraceClassUnloading这个用于追踪类卸载的信息</span></span><br><span class="line">        CustomClassLoader classLoader2 = <span class="keyword">new</span> CustomClassLoader(<span class="string">"myCustomClassLoader2"</span>);</span><br><span class="line">        classLoader2.setPath(<span class="string">"/Users/ct/Downloads/testclassload/"</span>);</span><br><span class="line">        test(classLoader2);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行结果：</span></span><br><span class="line"><span class="comment">         * myCustomClassLoader的findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">         * com.ct.jvm.classloader.CustomClassLoader@2503dbd3</span></span><br><span class="line"><span class="comment">         * 2125039532</span></span><br><span class="line"><span class="comment">         * -------------------------------------</span></span><br><span class="line"><span class="comment">         * myCustomClassLoader2的findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">         * com.ct.jvm.classloader.CustomClassLoader@12a3a380</span></span><br><span class="line"><span class="comment">         * 1554874502</span></span><br><span class="line"><span class="comment">         * -------------------------------------</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"com.ct.jvm.classloader.ClassLoad1"</span>);</span><br><span class="line">        Object instance = clazz.newInstance();</span><br><span class="line">        System.out.println(instance.getClass().getClassLoader());</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类加载器命名空间问题"><a href="#类加载器命名空间问题" class="headerlink" title="类加载器命名空间问题"></a>类加载器命名空间问题</h3><hr><ul><li><p>每个类加载器都有自己的命名空间，<strong>命名空间由该加载器及所有父加载器所加载的类构成</strong>；</p></li><li><p>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；</p></li><li><p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；</p></li><li><p>同一命名空间内的类是互相可见的，<strong>非同一命名空间内的类是不可见的</strong>；</p></li><li><p>子加载器可以见到父加载器加载的类，<strong>父加载器也不能见到子加载器加载的类</strong>。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoad14</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//这里需要做的操作是把target下面的MyPerson.class移动到/Users/changtong/Downloads/testclassload/com/ct/jvm/classloader/下</span></span><br><span class="line">        CustomClassLoader loader1 = <span class="keyword">new</span> CustomClassLoader(<span class="string">"load1"</span>);</span><br><span class="line">        loader1.setPath(<span class="string">"/Users/ct/Downloads/testclassload/"</span>);</span><br><span class="line">        CustomClassLoader loader2 = <span class="keyword">new</span> CustomClassLoader(<span class="string">"load2"</span>);</span><br><span class="line">        loader2.setPath(<span class="string">"/Users/ct/Downloads/testclassload/"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.ct.jvm.classloader.MyPerson"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.ct.jvm.classloader.MyPerson"</span>);</span><br><span class="line">        <span class="comment">//由于clazz1和clazz2分别有不同的类加载器所加载，所以他们处于不同的名称空间里</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = clazz1.getMethod(<span class="string">"setMyPerson"</span>, Object.class);</span><br><span class="line">        <span class="comment">//此处报错，loader1和loader2所处不用的命名空间</span></span><br><span class="line">        method.invoke(object1, object2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出结果：</span></span><br><span class="line"><span class="comment">        findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">        findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">        false</span></span><br><span class="line"><span class="comment">    Exception in thread "main" java.lang.reflect.InvocationTargetException</span></span><br><span class="line"><span class="comment">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span><br><span class="line"><span class="comment">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span><br><span class="line"><span class="comment">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span></span><br><span class="line"><span class="comment">        at java.lang.reflect.Method.invoke(Method.java:498)</span></span><br><span class="line"><span class="comment">        at com.ct.jvm.classloader.ClassLoad14.main(ClassLoad14.java:30)</span></span><br><span class="line"><span class="comment">        Caused by: java.lang.ClassCastException: com.ct.jvm.classloader.MyPerson cannot be cast to com.ct.jvm.classloader.MyPerson</span></span><br><span class="line"><span class="comment">        at com.ct.jvm.classloader.MyPerson.setMyPerson(MyPerson.java:8)</span></span><br><span class="line"><span class="comment">        ... 5 more</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类加载器双亲委托模型的好处"><a href="#类加载器双亲委托模型的好处" class="headerlink" title="类加载器双亲委托模型的好处"></a>类加载器双亲委托模型的好处</h3><hr><ul><li><strong>可以确保Java和核心库的安全：所有的Java应用都会引用java.lang中的类，也就是说在运行期java.lang中的类会被加载到虚拟机中，如果这个加载过程如果是由自己的类加载器所加载，那么很可能就会在JVM中存在多个版本的java.lang中的类，而且这些类是相互不可见的（命名空间的作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动根加载器去加载，从而确保了Java应用所使用的的都是同一个版本的Java核心类库，他们之间是相互兼容的；</strong></li><li><strong>确保Java核心类库中的类不会被自定义的类所替代；</strong></li><li><strong>不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器去加载即可。相当于在Java虚拟机内部建立了一个又一个相互隔离的Java类空间。</strong></li><li><strong>父亲委托机制的优点是能够提高软件系统的安全性。因此在此机制下，用户自定义的类加载器不可能加载应该由父类加载器加载的可靠类，从而防止不可靠甚至恶意的代码代替由父类加载器加载的可靠代码。例如，java.lang.Object类是由跟类加载器加载，其他任何用哪个户自定义的类加载器都不可能加载含有恶意代码的java.lang.Object类。</strong></li></ul><h3 id="类加载器补充"><a href="#类加载器补充" class="headerlink" title="类加载器补充"></a>类加载器补充</h3><hr><ul><li>类加载器本身也是类加载器，类加载器又是谁加载的呢？？（先有鸡还是现有蛋）<br>类加载器是由启动类加载器去加载的，启动类加载器是C++写的，内嵌在JVM中。</li><li>内嵌于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类。当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器以及系统类加载器，这块特殊的机器码叫做启动类加载器。</li><li>启动类加载器并不是java类，其他的加载器都是java类。</li><li>启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。</li></ul><h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><hr><ul><li><strong>当前类加载器(Current ClassLoader)</strong><br>每个类都会尝试使用自己的类加载器去加载依赖的类。</li></ul><ul><li><p><strong>线程上下文类加载器(Context ClassLoader)</strong><br>线程上下文加载器 @ jdk1.2<br>线程类中的<code>getContextClassLoader()</code>与 <code>setContextClassLoader(ClassLoader c)</code><br>如果没有通过<code>setContextClassLoader()</code>方法设置，线程将继承父线程的上下文类加载器，<br>java应用运行时的初始线程的上下文类加载器是系统类加载器。该线程中运行的代码可以通过该类加载器加载类和资源。</p></li><li><p><strong>线程上下文类加载器的作用：</strong><br><strong>SPI</strong>：<code>Service Provide Interface</code><br>父<code>ClassLoader</code>可以使用当前线程<code>Thread.currentThread().getContextClassLoader()</code>所制定的<code>ClassLoader</code>加载的类，<br>这就改变了父加载器加载的类无法使用子加载器或是其他没有父子关系的<code>ClassLoader</code>加载的类的情况，即改变了双亲委托模型。</p></li><li><p><strong>在双亲委托模型下</strong>，类加载是由下至上的，即下层的类加载器会委托父加载器进行加载。但是对于SPI来说，<br>有些接口是Java核心库所提供的的（如JDBC），Java核心库（如Connection接口）是由启动类加载器去加载的，而这些接口的实现却来自不同的jar包（<strong>默认会被添加到classes下，这样就会导致父加载器无法访问子类加载器所加载的类</strong>）（厂商提供），<br>Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。通过给当前线程设置上下文类加载器，<br>就可以由设置的上下文类加载器来实现对于接口实现类的加载。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoad16</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前类加载器(Current ClassLoader)</span></span><br><span class="line"><span class="comment">    * 每个类都会尝试使用自己的类加载器去加载依赖的类。</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 线程上下文类加载器(Context ClassLoader)</span></span><br><span class="line"><span class="comment">    * 线程上下文加载器 @ jdk1.2</span></span><br><span class="line"><span class="comment">    * 线程类中的 getContextClassLoader() 与 setContextClassLoader(ClassLoader c)</span></span><br><span class="line"><span class="comment">    * 如果没有通过setContextClassLoader()方法设置，线程将继承父线程的上下文类加载器，</span></span><br><span class="line"><span class="comment">    * java应用运行时的初始线程的上下文类加载器是系统类加载器。该线程中运行的代码可以通过该类加载器加载类和资源。</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 线程上下文类加载器的作用：</span></span><br><span class="line"><span class="comment">    * SPI：Service Provide Interface</span></span><br><span class="line"><span class="comment">    * 父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所制定的ClassLoader加载的类，</span></span><br><span class="line"><span class="comment">    * 这就改变了父加载器加载的类无法使用子加载器或是其他没有父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托父加载器进行加载。但是对于SPI来说，</span></span><br><span class="line"><span class="comment">    * 有些接口是Java核心库所提供的的（如JDBC），Java核心库是由启动类记载器去加载的，而这些接口的实现却来自不同的jar包（厂商提供），</span></span><br><span class="line"><span class="comment">    * Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。通过给当前线程设置上下文类加载器，</span></span><br><span class="line"><span class="comment">    * 就可以由设置的上下文类加载器来实现对于接口实现类的加载。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(Thread.class.getClassLoader());</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.system.class.loader"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程上下文类加载器的使用"><a href="#线程上下文类加载器的使用" class="headerlink" title="线程上下文类加载器的使用"></a>线程上下文类加载器的使用</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 线程上下文类加载器的一般使用模式：（获取-使用-还原）</span></span><br><span class="line"><span class="comment">* 伪代码：</span></span><br><span class="line"><span class="comment">* ClassLoader classLoader=Thread.currentThread().getContextLoader();</span></span><br><span class="line"><span class="comment">* try&#123;</span></span><br><span class="line"><span class="comment">* Thread.currentThread().setContextLoader(targetTccl);</span></span><br><span class="line"><span class="comment">* myMethod();</span></span><br><span class="line"><span class="comment">* &#125;finally&#123;</span></span><br><span class="line"><span class="comment">* Thread.currentThread().setContextLoader(classLoader);</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">* 在myMethod中调用Thread.currentThread().getContextLoader()做某些事情</span></span><br><span class="line"><span class="comment">* ContextClassLoader的目的就是为了破坏类加载委托机制</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 在SPI接口的代码中，使用线程上下文类加载器就可以成功的加载到SPI的实现类。</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 当高层提供了统一的接口让底层去实现，同时又要在高层加载（或实例化）底层的类时，</span></span><br><span class="line"><span class="comment">* 就必须通过上下文类加载器来帮助高层的ClassLoader找到并加载该类。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoad17</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一旦加入下面此行，将使用ExtClassLoader去加载Driver.class， ExtClassLoader不会去加载classpath，因此无法找到MySql的相关驱动。</span></span><br><span class="line">        <span class="comment">//Thread.getCurrentThread().setContextClassLoader(MyTest26.class.getClassLoader().parent());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ServiceLoader服务提供者，加载实现的服务</span></span><br><span class="line">        ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = loader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Driver driver = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"driver:"</span> + driver.getClass() + <span class="string">",loader"</span> + driver.getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"当前上下文加载器"</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"ServiceLoader的加载器"</span> + ServiceLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><hr><ul><li>当一个类被加载、连接和初始化之后，它的生命周期就开始了。当此类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载。</li><li>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</li><li>由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机本身会始终引用这些加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象是可触及的。</li><li>由用户自定义的类加载器所加载的类是可以被卸载的。（<strong>jvisualvm 查看当前java进程 -XX:+TraceClassUnloading这个用于追</strong>）</li></ul><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{      CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(<span class="string">"myCustomClassLoader"</span>);      classLoader.setPath(<span class="string">"/Users/ct/Downloads/testclassload/"</span>);      test(classLoader);      classLoader = <span class="keyword">null</span>;      System.gc();      Thread.sleep(<span class="number">10000</span>); <span class="comment">// jvisualvm 查看当前java进程 -XX:+TraceClassUnloading这个用于追踪类卸载的信息</span>      CustomClassLoader classLoader2 = <span class="keyword">new</span> CustomClassLoader(<span class="string">"myCustomClassLoader2"</span>);      classLoader2.setPath(<span class="string">"/Users/ct/Downloads/testclassload/"</span>);      test(classLoader2);      <span class="comment">/**</span><span class="comment">       * 执行结果：</span><span class="comment">       * myCustomClassLoader的findClass,输出这句话说明我们自己的类加载器加载了指定的类</span><span class="comment">       * com.ct.jvm.classloader.CustomClassLoader@2503dbd3</span><span class="comment">       * 2125039532</span><span class="comment">       * -------------------------------------</span><span class="comment">       * myCustomClassLoader2的findClass,输出这句话说明我们自己的类加载器加载了指定的类</span><span class="comment">       * com.ct.jvm.classloader.CustomClassLoader@12a3a380</span><span class="comment">       * 1554874502</span><span class="comment">       * -------------------------------------</span><span class="comment">       */</span>  }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下学习jvm类加载这一章节的知识点，方便日后查阅.&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://tomchangt.github.io/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://tomchangt.github.io/tags/Java/"/>
    
      <category term="Jvm" scheme="https://tomchangt.github.io/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>spring5.1.x源码学习——源码环境搭建</title>
    <link href="https://tomchangt.github.io/2019/04/23/spring5-1-x%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://tomchangt.github.io/2019/04/23/spring5-1-x源码学习——源码环境搭建/</id>
    <published>2019-04-23T13:47:44.000Z</published>
    <updated>2020-01-02T07:11:22.678Z</updated>
    
    <content type="html"><![CDATA[<p>作者也工作这么多年了,工作用到最多的框架就是spring了,但是从来也没有去读过spring源码,所以决定以写blog的方式记录一下我的spring源码学习之旅,本篇文章将记录spring的源码环境搭建.</p><a id="more"></a><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><hr><p>作者用的的macbook pro.</p><p><img src="step02.png" alt></p><p>spring5要求jdk最低版本是8,所以作者用的是jdk1.8.0_111.</p><p><img src="step01.png" alt></p><p>spring源码是基于gradle构建的,所以需要安装gradle.mac下安装gradle因为还是很方便的(自行google),只不过下载可能需要科学工具,这里作者用到的是gradle 4.10.3.</p><p><img src="step03.png" alt></p><p>作者用到的ide工具是idea2019(官网直接下载旗舰版,找马云爸爸要注册码).</p><p><img src="step04.png" alt></p><blockquote><p> 这里有点要注意下,低版本的idea对gradle的支持不是很好,作者之前用idea2016导spring的时候出现过好多坑,所以建议升级到较新的idea.</p></blockquote><h4 id="spring源码下载"><a href="#spring源码下载" class="headerlink" title="spring源码下载"></a>spring源码下载</h4><hr><p>基本spring源码下载分二种,一种是git直接下载,一种是去<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">官方下载</a>zip包,这里作者是直接去官网下载spring5.1.x的zip包.</p><p><img src="step05.png" alt></p><h4 id="spring源码导入"><a href="#spring源码导入" class="headerlink" title="spring源码导入"></a>spring源码导入</h4><hr><p>在编译之前安装进入解压目录找到<code>import-into-idea.md</code>文件,这个文件告诉了你导入idea要注意的一些事项,例如先要编译<code>spring-core</code> 和 <code>spring-oxm</code> 模块等等,接下来我就用截图展示下我编译的步骤.</p><p><img src="step06.png" alt></p><p><img src="step07.png" alt></p><p><img src="step08.png" alt></p><p><img src="step09.png" alt></p><p><img src="step10.png" alt></p><p><img src="step11.png" alt></p><p>至此spring源码已经导入到idea里面了,接下来我便会开始开启我的spring源码阅读之旅.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者也工作这么多年了,工作用到最多的框架就是spring了,但是从来也没有去读过spring源码,所以决定以写blog的方式记录一下我的spring源码学习之旅,本篇文章将记录spring的源码环境搭建.&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://tomchangt.github.io/categories/Java/"/>
    
    
      <category term="Spring" scheme="https://tomchangt.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO 学习笔记</title>
    <link href="https://tomchangt.github.io/2019/04/21/Java%20NIO%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://tomchangt.github.io/2019/04/21/Java NIO 学习笔记/</id>
    <published>2019-04-21T06:47:16.000Z</published>
    <updated>2019-12-31T02:36:29.780Z</updated>
    
    <content type="html"><![CDATA[<p>Java NIO是java 1.4之后新出的一套IO接口，这里的的新是相对于原有标准的Java IO和Java Networking接口。NIO提供了一种完全不同的操作方式。</p><a id="more"></a><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><hr><p>这里就不过多的去解释一些概念性的东西了,直奔主题.NIO包含下面几个核心的组件：</p><blockquote><ul><li>Buffer</li><li>Channel</li><li>Selector</li></ul></blockquote><p>整个NIO体系包含的类远远不止这几个，但是在我看来Channel,Buffer和Selector组成了这个核心的API.</p><h5 id="通道和缓冲区（Channel-and-Buffer）"><a href="#通道和缓冲区（Channel-and-Buffer）" class="headerlink" title="通道和缓冲区（Channel and Buffer）"></a>通道和缓冲区（Channel and Buffer）</h5><p>通常来说NIO中的所有IO都是从Channel开始的。Channel和流有点类似。通过Channel，我们即可以从Channel把数据写到Buffer中，也可以把数据冲Buffer写入到Channel,如下所示:</p><p><img src="01.png" alt></p><p>基本的Channel实现有以下这些：</p><blockquote><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul></blockquote><p>核心的buffer实现有这些：</p><blockquote><ul><li>ByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul></blockquote><p>这些Buffer涵盖了可以通过IO操作的基础类型：byte,short,int,long,float,double以及characters. NIO实际上还包含一种MappedBytesBuffer,一般用于和内存映射的文件.</p><h5 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h5><p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。</p><p><img src="02.png" alt></p><h4 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h4><hr><p>buffer就是一块内存，你可以写入数据，并且在之后读取它。这块内存被包装成NIO buffer对象，它提供了一些方法来让你更简单地操作内存。</p><h5 id="Buffer的基本使用"><a href="#Buffer的基本使用" class="headerlink" title="Buffer的基本使用"></a>Buffer的基本使用</h5><p>利用Buffer读写数据，通常遵循四个步骤:</p><blockquote><ul><li>把数据写入buffer</li><li>调用flip,切换读写模式</li><li>从Buffer中读取数据</li><li>调用buffer.clear()或者buffer.compact()</li></ul></blockquote><p>在写buffer的时候，buffer会跟踪写入了多少数据，需要读buffer的时候，需要调用flip()来将buffer从写模式切换成读模式，读模式中只能读取写入的数据，而非整个buffer,当数据都读完了，你需要清空buffer以供下次使用，可以有2种方法来操作:</p><blockquote><ul><li>调用clear()</li><li>调用compact()</li></ul></blockquote><p>区别：clear方法清空整个buffer，compact方法只清除你已经读取的数据，未读取的数据会被移到buffer的开头，此时写入数据会从当前数据的末尾开始.这里有一个简单的buffer案例:</p><pre><code>public static void main(String[] args) {    IntBuffer intBuffer = IntBuffer.allocate(10);    for(int i = 0;i&lt;intBuffer.capacity();++i){        //往buffer放数据        intBuffer.put(i*2);    }    //切换成读模式    intBuffer.flip();    while (intBuffer.hasRemaining()) {        System.out.println(&quot;buffer data : &quot;+intBuffer.get());    }}</code></pre><h5 id="Buffer的容量，位置，上限（Buffer-Capacity-Position-and-Limit）"><a href="#Buffer的容量，位置，上限（Buffer-Capacity-Position-and-Limit）" class="headerlink" title="Buffer的容量，位置，上限（Buffer Capacity, Position and Limit）"></a>Buffer的容量，位置，上限（Buffer Capacity, Position and Limit）</h5><p>buffer最主要的三个属性是需要我们理解的:</p><blockquote><ul><li>容量(Capacity):缓冲区能够容纳的数据元素的最大数量.容量在缓冲区创建时被设定,并且永远不能被改变。</li><li>上界(Limit):写模式中等价于buffer的大小,即capacity;读模式中为当前缓冲区中一共有多少数据,即可读的最大位置.这意味着当调用filp()方法切换成读模式时,limit的值变成position的值,而position重新指向0.</li><li>位置(Position):下一个要被读或写的元素的位置.初始化为0,buffer满时,position最大值为capacity-1.切换成读模式的时候,position指向0.Position会自动由相应的get()和put()函数更新。</li></ul></blockquote><p>position和limit的值在读/写模式中是不一样的,capacity的值永远表示buffer的大小。</p><p>下图解释了在读/写模式中Capacity,Position和Limit的含义:</p><p><img src="03.png" alt></p><h5 id="关于-Direct-Buffer-和-Non-Direct-Buffer-的区别"><a href="#关于-Direct-Buffer-和-Non-Direct-Buffer-的区别" class="headerlink" title="关于 Direct Buffer 和 Non-Direct Buffer 的区别"></a>关于 Direct Buffer 和 Non-Direct Buffer 的区别</h5><p>Direct Buffer:</p><blockquote><ul><li>所分配的内存不在JVM堆上,不受GC的管理.(但是Direct Buffer的Java对象是由GC管理的,因此当发生GC,对象被回收时,Direct Buffer也会被释放)</li><li>因为Direct Buffer不在JVM堆上分配,因此Direct Buffer对应用程序的内存占用的影响就不那么明显(实际上还是占用了这么多内存,但是JVM不好统计到非JVM管理的内存.)</li><li>申请和释放Direct Buffer的开销比较大.因此正确的使用Direct Buffer的方式是在初始化时申请一个Buffer,然后不断复用此buffer,在程序结束后才释放此 buffer.</li><li>使用Direct Buffer时,当进行一些底层的系统IO操作时,效率会比较高,因为此时JVM不需要拷贝buffer中的内存到中间临时缓冲区中.</li></ul></blockquote><p>Non-Direct Buffer:</p><blockquote><ul><li>直接在JVM堆上进行内存的分配,本质上是byte[]数组的封装.</li><li>因为Non-Direct Buffer在JVM堆中,因此当进行操作系统底层IO操作中时,会将此buffer的内存复制到中间临时缓冲区中.因此Non-Direct Buffer的效率就较低.</li></ul></blockquote><h4 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h4><hr><p>通常来说, 所有的NIO的 I/O 操作都是从Channel开始的. 一个Channel类似于一个Stream.主要有以下几点区别：</p><blockquote><ul><li>Channel可以读也可以写，Stream一般来说是单向的（只能读或者写）。</li><li>Channel可以异步读写。</li><li>Channel总是基于缓冲区Buffer来读写。</li></ul></blockquote><p>Channel 的主要类型有:</p><blockquote><ul><li>FileChannel用于文件的数据读写.</li><li>DatagramChannel用于UDP的数据读写。</li><li>SocketChannel用于TCP的数据读写。</li><li>ServerSocketChannel允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel.在服务器端使用.</li></ul></blockquote><p>这有一个利用FileChannel进行文件拷贝的例子：</p><pre><code>public static void main(String[] args) throws Exception {    String fileInStr = &quot;fileCopy_in.txt&quot;;    String fileOutStr = &quot;fileCopy_out.txt&quot;;    RandomAccessFile  inputFile = new RandomAccessFile(fileInStr,&quot;r&quot;);    RandomAccessFile  outFile = new RandomAccessFile(fileOutStr,&quot;rw&quot;);    long length = new File(fileInStr).length();    FileChannel inputFileChannel = inputFile.getChannel();    FileChannel outFileChannel = outFile.getChannel();    MappedByteBuffer inputData = inputFileChannel.map(FileChannel.MapMode.READ_ONLY, 0, length);    Charset charset = Charset.forName(&quot;utf-8&quot;);    CharsetDecoder charsetDecoder = charset.newDecoder();    CharsetEncoder charsetEncoder = charset.newEncoder();    CharBuffer charBuffer = charsetDecoder.decode(inputData);    ByteBuffer outByteBuffer = charsetEncoder.encode(charBuffer);    outFileChannel.write(outByteBuffer);    inputFile.close();    outFile.close();}</code></pre><h4 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器(Selector)"></a>选择器(Selector)</h4><hr><p>Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写.如此可以实现单线程管理多个channels,也就是可以管理多个网络链接.</p><h5 id="为什么使用Selector"><a href="#为什么使用Selector" class="headerlink" title="为什么使用Selector"></a>为什么使用Selector</h5><p>用单线程处理多个channels的好处是我需要更少的线程来处理channel.实际上,你甚至可以用一个线程来处理所有的channels.从操作系统的角度来看,切换线程开销是比较昂贵的,并且每个线程都需要占用系统资源,因此暂用线程越少越好。需要留意的是,现代操作系统和CPU在多任务处理上已经变得越来越好,所以多线程带来的影响也越来越小.如果一个CPU是多核的,如果不执行多任务反而是浪费了机器的性能.不过这些设计讨论是另外的话题了。简而言之,通过Selector我们可以实现单线程操作多个channel.</p><h6 id="创建Selector"><a href="#创建Selector" class="headerlink" title="创建Selector"></a>创建Selector</h6><pre><code>Selector selector = Selector.open();</code></pre><h6 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h6><pre><code>channel.configureBlocking(false);SelectionKey key = channel.register(selector,Selectionkey.OP_READ);</code></pre><p>注意,如果一个Channel要注册到Selector中,那么这个Channel必须是非阻塞的,即channel.configureBlocking(false);因为Channel必须要是非阻塞的,因此FileChannel是不能够使用选择器的, 因为FileChannel都是阻塞的,注意register的第二个参数，这个参数是一个“关注集合”，代表我们关注的channel状态，有四种基础类型可供监听：</p><blockquote><ul><li>Connect</li><li>Accept</li><li>Read</li><li>Write</li></ul></blockquote><p>一个channel触发了一个事件也可视作该事件处于就绪状态.因此当channel与server连接成功后，那么就是“连接就绪”状态.server channel接收请求连接时处于“可连接就绪”状态。channel有数据可读时处于“读就绪”状态。channel可以进行数据写入时处于“写就绪”状态,上述的四种就绪状态用SelectionKey中的常量表示如下:</p><blockquote><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul></blockquote><p>如果对多个事件感兴趣可利用位的或运算结合多个常量,比如:</p><pre><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; </code></pre><p>我们利用register方法把Channel注册到了Selectors上,这个方法的返回值是SelectionKeys,这个返回的对象包含了一些比较有价值的属性:</p><blockquote><ul><li>The interest set</li><li>The ready set</li><li>The Channel</li><li>The Selector</li><li>An attached object (optional)</li></ul></blockquote><h6 id="Interest-Set"><a href="#Interest-Set" class="headerlink" title="Interest Set"></a>Interest Set</h6><p>这个“关注集合”实际上就是我们希望处理的事件的集合，它的值就是注册时传入的参数，我们可以用按为与运算把每个事件取出来:</p><pre><code>int interestSet = selectionKey.interestOps();boolean isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE; </code></pre><h6 id="Ready-Set"><a href="#Ready-Set" class="headerlink" title="Ready Set"></a>Ready Set</h6><p>“就绪集合”中的值是当前channel处于就绪的值，一般来说在调用了select方法后都会需要用到就绪状态，select的介绍在胡须文章中继续展开。</p><pre><code>int readySet = selectionKey.readyOps();</code></pre><p>从“就绪集合”中取值的操作类似月“关注集合”的操作,当然还有更简单的方法，SelectionKey提供了一系列返回值为boolean的的方法:</p><pre><code>selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable();</code></pre><h6 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h6><p>从SelectionKey操作Channel和Selector非常简单:</p><pre><code>Channel  channel  = selectionKey.channel();Selector selector = selectionKey.selector();  </code></pre><h6 id="Attaching-Objects"><a href="#Attaching-Objects" class="headerlink" title="Attaching Objects"></a>Attaching Objects</h6><p>我们可以给一个SelectionKey附加一个Object，这样做一方面可以方便我们识别某个特定的channel，同时也增加了channel相关的附加信息。例如，可以把用于channel的buffer附加到SelectionKey上:</p><pre><code>selectionKey.attach(theObject);Object attachedObj = selectionKey.attachment();</code></pre><p>附加对象的操作也可以在register的时候就执行:</p><pre><code>SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</code></pre><h6 id="从Selector中选择channel"><a href="#从Selector中选择channel" class="headerlink" title="从Selector中选择channel"></a>从Selector中选择channel</h6><p>一旦我们向Selector注册了一个或多个channel后，就可以调用select来获取channel.select方法会返回所有处于就绪状态的channel.select方法具体如下:</p><blockquote><ul><li>int select()</li><li>int select(long timeout)</li><li>int selectNow()</li></ul></blockquote><p>select()方法在返回channel之前处于阻塞状态.select(long timeout)和select做的事一样，不过他的阻塞有一个超时限制.selectNow()不会阻塞,根据当前状态立刻返回合适的channel.select()方法的返回值是一个int整形,代表有多少channel处于就绪了.也就是自上一次select后有多少channel进入就绪.举例来说,假设第一次调用select时正好有一个channel就绪,那么返回值是1,并且对这个channel做任何处理，接着再次调用select,此时恰好又有一个新的channel就绪,那么返回值还是1,现在我们一共有两个channel处于就绪,但是在每次调用select时只有一个channel是就绪的.</p><h6 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h6><p>在调用select并返回了有channel就绪之后，可以通过选中的key集合来获取channel，这个操作通过调用selectedKeys()方法:</p><pre><code>Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();    </code></pre><p>还记得在register时的操作吧，我们register后的返回值就是SelectionKey实例，也就是我们现在通过selectedKeys()方法所返回的SelectionKey.遍历这些SelectionKey可以通过如下方法:</p><pre><code>Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();while(keyIterator.hasNext()) {    SelectionKey key = keyIterator.next();    if(key.isAcceptable()) {        // a connection was accepted by a ServerSocketChannel.    } else if (key.isConnectable()) {        // a connection was established with a remote server.    } else if (key.isReadable()) {        // a channel is ready for reading    } else if (key.isWritable()) {        // a channel is ready for writing    }    keyIterator.remove();}</code></pre><p>上述循环会迭代key集合,针对每个key我们单独判断他是处于何种就绪状态.注意keyIterater.remove()方法的调用,Selector本身并不会移除SelectionKey对象,这个操作需要我们收到执行.当下次channel处于就绪是,Selector任然会吧这些key再次加入进来.SelectionKey.channel返回的channel实例需要强转为我们实际使用的具体的channel类型,例如ServerSocketChannel或SocketChannel.</p><h6 id="wakeUp"><a href="#wakeUp" class="headerlink" title="wakeUp()"></a>wakeUp()</h6><p>由于调用select而被阻塞的线程,可以通过调用Selector.wakeup()来唤醒即便此时已然没有channel处于就绪状态.具体操作是，在另外一个线程调用wakeup,被阻塞与select方法的线程就会立刻返回。</p><h6 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h6><p>当操作Selector完毕后,需要调用close方法.close的调用会关闭Selector并使相关的SelectionKey都无效.channel本身不管被关闭.</p><h6 id="完整的Selector案例"><a href="#完整的Selector案例" class="headerlink" title="完整的Selector案例"></a>完整的Selector案例</h6><p>Server端:</p><pre><code>public class NioServer {    private static Map&lt;String,SocketChannel&gt; channelMap = new HashMap();    private static Map&lt;Integer, BiConsumer&lt;SelectionKey,Selector&gt;&gt; rule = new HashMap();    public static void acceptable(SelectionKey selectionKey,Selector selector){        try {            ServerSocketChannel server = (ServerSocketChannel)selectionKey.channel();            SocketChannel client = server.accept();            client.configureBlocking(false);            client.register(selector,SelectionKey.OP_READ);            String key = &quot;【&quot;+ UUID.randomUUID().toString() +&quot;】&quot;;            channelMap.put(key,client);        }catch (Exception e){            e.printStackTrace();        }    }    public static void readable(SelectionKey selectionKey,Selector selector){        try {            SocketChannel client = (SocketChannel)selectionKey.channel();            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);            int count = client.read(byteBuffer);            if(count&gt;0) {                byteBuffer.flip();                Charset charset = Charset.forName(&quot;utf-8&quot;);                String receivedMessage = String.valueOf(charset.decode(byteBuffer).array());                String clientKey = channelMap.entrySet().stream().filter(entry -&gt; entry.getValue() == client).findFirst().                        map(entry -&gt; entry.getKey()).orElse(null);                final String clientReceivedMessage = clientKey + &quot; : &quot; + receivedMessage;                System.out.println(clientReceivedMessage);                //把消息广播出去                channelMap.entrySet().stream().filter(entry-&gt;!entry.getKey().equals(clientKey))                        .forEach(entry-&gt;{                            try {                                SocketChannel otherClient = entry.getValue();                                ByteBuffer writeBuffer = ByteBuffer.allocate(1024);                                writeBuffer.put(clientReceivedMessage.getBytes());                                writeBuffer.flip();                                otherClient.write(writeBuffer);                            }catch (Exception e){                                e.printStackTrace();                            }                        });            }        }catch (Exception e){            e.printStackTrace();        }    }    public static void main(String[] args) {        rule.put(SelectionKey.OP_ACCEPT,NioServer::acceptable);        rule.put(SelectionKey.OP_READ,NioServer::readable);        try {            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();            serverSocketChannel.configureBlocking(false);            ServerSocket socket = serverSocketChannel.socket();            socket.bind(new InetSocketAddress(&quot;127.0.0.1&quot;,8899));            Selector selector = Selector.open();            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);            while (true){                try {                    selector.select();                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                    selectionKeys.forEach(selectionKey -&gt; {                        if (selectionKey.isAcceptable()) {                            rule.get(SelectionKey.OP_ACCEPT).accept(selectionKey, selector);                        } else if (selectionKey.isReadable()) {                            rule.get(SelectionKey.OP_READ).accept(selectionKey, selector);                        }                    });                    selectionKeys.clear();                }catch (Exception e){                    e.printStackTrace();                }            }        }catch (Exception e){            e.printStackTrace();        }    }}   </code></pre><p>Client端:</p><pre><code>public class NioClient {    public static void main(String[] args) {        try {            SocketChannel socketChannel = SocketChannel.open();            socketChannel.configureBlocking(false);            Selector selector = Selector.open();            socketChannel.register(selector, SelectionKey.OP_CONNECT);            socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,8899));            while (true){                selector.select();                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                selectionKeys.forEach(selectionKey-&gt;{                    try {                        if (selectionKey.isConnectable()) {                            SocketChannel client = (SocketChannel)selectionKey.channel();                            if(client.isConnectionPending()){                                client.finishConnect();                                ByteBuffer writeBuffer = ByteBuffer.allocate(1024);                                writeBuffer.put((LocalDateTime.now() + &quot; 连接成功....&quot;).getBytes());                                writeBuffer.flip();                                client.write(writeBuffer);                                ExecutorService executorService = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());                                executorService.submit(()-&gt;{                                    while (true){                                        try {                                            writeBuffer.clear();                                            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));                                            String sendMessage = br.readLine();                                            writeBuffer.put(sendMessage.getBytes());                                            writeBuffer.flip();                                            client.write(writeBuffer);                                        }catch (Exception e){                                            e.printStackTrace();                                        }                                    }                                });                            }                        client.register(selector,SelectionKey.OP_READ);                        }else if(selectionKey.isReadable()){                            SocketChannel client = (SocketChannel)selectionKey.channel();                            ByteBuffer readBuffer = ByteBuffer.allocate(1024);                            int count = client.read(readBuffer);                            if(count&gt;0){                                String receivedMessage = new String(readBuffer.array(),0,count);                                System.out.println(receivedMessage);                            }                        }                    }catch (Exception e){                        e.printStackTrace();                    }                });                selectionKeys.clear();            }        }catch (Exception e){            e.printStackTrace();        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java NIO是java 1.4之后新出的一套IO接口，这里的的新是相对于原有标准的Java IO和Java Networking接口。NIO提供了一种完全不同的操作方式。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://tomchangt.github.io/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://tomchangt.github.io/tags/Java/"/>
    
      <category term="NIO" scheme="https://tomchangt.github.io/tags/NIO/"/>
    
      <category term="Netty" scheme="https://tomchangt.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github 博客搭建教程</title>
    <link href="https://tomchangt.github.io/2019/04/20/Hexo-Github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>https://tomchangt.github.io/2019/04/20/Hexo-Github-博客搭建教程/</id>
    <published>2019-04-20T02:37:48.000Z</published>
    <updated>2019-11-21T05:48:00.116Z</updated>
    
    <content type="html"><![CDATA[<p>最近有想法重新开始写博客了,随着年纪越来越大,需要有些沉淀的东西.16年的时候用hexo+github搭建过博客系统,于是花了点时间重新弄了一遍.我就稍稍分享一下搭建过程,当作是我这个博客的第一篇文章.</p><a id="more"></a><h4 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h4><hr><blockquote><ul><li>macOS Mojave 10.14.5</li><li>Nodejs v12.1.0</li><li>Npm v6.9.0</li><li>Git v2.20.1</li></ul></blockquote><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>因为本人本身是后端开发,加上系统用的是macOS,所有git和node都有提前装好,网上很多mac下安装git和node的教程,我这里就不阐述了.安装好git和node以后开始安装Hexo.找一个合适的目录来存放你的博客文件,比如我这里新建了一个blog文件夹来放置我的博客文件 <code>~/WorkStation/WorkStation/blog</code>,进入blog文件夹下开始安装.</p><h5 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h5><pre><code>npm install -g hexo-cli</code></pre><h5 id="2-初始化hexo"><a href="#2-初始化hexo" class="headerlink" title="2.初始化hexo"></a>2.初始化hexo</h5><pre><code>hexo init</code></pre><h5 id="3-安装必要组件"><a href="#3-安装必要组件" class="headerlink" title="3.安装必要组件"></a>3.安装必要组件</h5><pre><code>npm install</code></pre><p>安装完成后我本地目录结构如下:</p><p><img src="01.png" alt>    </p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<code>http://localhost:4000/</code>，就可以访问了,效果如下:</p><p><img src="02.jpg" alt></p><h5 id="4-使用-Hexo"><a href="#4-使用-Hexo" class="headerlink" title="4.使用 Hexo"></a>4.使用 Hexo</h5><p>Hexo经常会用到的命令:</p><blockquote><ul><li>hexo clean </li><li>hexo generate</li><li>hexo server</li><li>hexo deploy</li></ul></blockquote><p>Hexo命令大多可以缩写,比如<code>hexo s 、 hexo d</code>等等.<br>更多详细命令可以参照<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">官方文档</a>.</p><h4 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h4><hr><h5 id="1-创建Repository"><a href="#1-创建Repository" class="headerlink" title="1.创建Repository"></a>1.创建Repository</h5><p>在自己的github上新建一个repository,这里注意一下我名字tomchangt,所以我的repository name要填写tomchangt.github.io,名字遵从 yourname.github.io格式,不过这里填错了也没关系,后面可以修改回来.</p><p><img src="03.png" alt></p><h5 id="2-链接github与本地"><a href="#2-链接github与本地" class="headerlink" title="2.链接github与本地"></a>2.链接github与本地</h5><p>打开terminal,然后输入下面命令:</p><pre><code>git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></pre><p>生成密钥SSH key:</p><pre><code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code></pre><p>然后找到刚才生成的.ssh文件下的文件<code>id_rsa.pub</code>密钥,用文本编辑器打开复制里面的内容.    </p><p><img src="04.png" alt></p><p>打开你的github,在点击<code>settings</code>,在点击<code>SSH and GPG keys</code>,新建一个ssh,名字可以随便.然后将刚才复制<code>id_rsa.pub</code>里的内容复制到key里面,点击<code>add ssh key</code>即可.</p><p><img src="05.png" alt></p><p><img src="06.png" alt></p><h5 id="3-配置本地hexo"><a href="#3-配置本地hexo" class="headerlink" title="3.配置本地hexo"></a>3.配置本地hexo</h5><p>在Hexo目录下的<code>_config.yml</code>文件下修改以下信息</p><pre><code># Deployment# Docs: http://hexo.io/docs/deployment.html  deploy:    type: git    repository: https://github.com/xxxx/xxxx.github.io.git     branch: master</code></pre><p>安装hexo deployer插件</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>执行下面命令,将hexo生成静态文件提交到github上,过一会你就可以在<code>https://xxxxxx.github.io</code>下看到博客内容了.</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><hr><p>简单的就写这么多吧,其实网上Hexo+Github建博客教程太多了,我也只是记录以下我建立博客的一个过程,并且将它当作我博客的第一篇文章,算是一个新的开始吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有想法重新开始写博客了,随着年纪越来越大,需要有些沉淀的东西.16年的时候用hexo+github搭建过博客系统,于是花了点时间重新弄了一遍.我就稍稍分享一下搭建过程,当作是我这个博客的第一篇文章.&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://tomchangt.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Hexo" scheme="https://tomchangt.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://tomchangt.github.io/tags/NexT/"/>
    
  </entry>
  
</feed>
